//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

@class MISSING_TYPE, NSArray, NSDate, NSMutableArray, RS3DSurface, RSSemanticImage, RSTextCoachingSignal;

#pragma mark Named Structures

struct BackBone_Param {
    _Bool single_resolution;
    struct vector<unsigned long, std::allocator<unsigned long>> fixed_input_shape;
    struct map<std::vector<unsigned long>, std::string, std::less<std::vector<unsigned long>>, std::allocator<std::pair<const std::vector<unsigned long>, std::string>>> dynamic_input_shape;
    unsigned long long max_K;
    float junc_score_thres;
    float fpn_len_range_max;
    float fpn_len_range_min;
    unsigned long long n_pts0;
    unsigned long long n_pts1;
    unsigned long long dim_fc;
    unsigned long long dim_loi;
    float cls_score_thres;
    _Bool filter_line_proposal;
};

struct CGPoint {
    double x;
    double y;
};

struct CGRect {
    struct CGPoint origin;
    struct CGSize size;
};

struct CGSize {
    double width;
    double height;
};

struct CoachingModel {
    struct Mat _w1;
    struct Mat _b1;
    struct Mat _w2;
    struct Mat _b2;
};

struct DRIFT_DETECTION_CONFIG {
    float xyz_speed_drift_thres;
    float view_speed_drift_thres;
    float feature_pts_match_thres;
    float feature_pts_similarity_thres;
    float flying_away_frames;
    float flying_away_angle_thres;
    float flying_away_xyz_speed_drift_thres;
    float flying_away_view_speed_drift_thres;
    float big_align_gap_wall_len_thres;
    float big_align_gap_thres;
    float big_align_gap_search_thres;
    float big_align_area_thres;
    float pose_get_stuck_eps;
    int n_lost_track_thr;
};

struct DistanceCoaching {
    float _threshold;
    struct deque<float, std::allocator<float>> _score_queue;
    struct deque<float, std::allocator<float>> _smooth_queue;
    float _latest_meand;
    struct CoachingModel _model;
};

struct DriftFrameInternalWraper;

struct EdgeRefinement;

struct GeometryMeta {
    _Bool is_center_scale_updated;
    float pixel_size;
    float floor_height;
    float ceiling_height;
    float support_height;
    int center__scale__shift__image_size;
    int floor_ceiling_count__z_slice;
    float visual_ceiling_height;
    float visual_floor_height;
};

struct GlobalOptimization {
    CDUnknownFunctionPointerType *_vptr$GlobalOptimization;
    float small_wall_len_thr;
    float small_wall_score_thr;
    float corner_dis_thr;
    float noise_small_wall_len_thr;
    float occlusion_thr;
    float ceiling_visible_thr;
    float gap_to_ceiling_thr;
    float window_upper_thr;
    float window_lower_thr;
    float window_len_thr;
    float mirror_thr;
    float stair_thr;
    float occlusion_score_thr;
    float edge_score_thr;
    float uniform_height_merge_thr;
    float uniform_and_slanted_height_refine_thr;
    float neighbor_height_align_thr;
};

struct HeightCoreEspV1 {
    CDUnknownFunctionPointerType *_vptr$HeightCoreBase;
    RSSemanticImage *_height_model_input;
    struct LineGeneration _line_generator;
    struct GlobalOptimization _global_optimization;
    unsigned int flt_type;
    struct vector<std::string, std::allocator<std::string>> _inputs_name;
    struct vector<std::string, std::allocator<std::string>> _outputs_name;
    struct vector<roomscancore::nuh_model::post_type::Path3D, std::allocator<roomscancore::nuh_model::post_type::Path3D>> _path_pool;
    struct PathFusion _path_fusion;
    struct Simplification *_simplification_online;
    struct Simplification *_simplification_offline;
    struct IEspresso_Interface_v1 _net;
};

struct HeightLineFit {
    CDUnknownFunctionPointerType *_vptr$HeightLineFit;
    float edge_score_thr;
    int noise_thr;
    float pixel_sz;
    float valid_length_thr;
};

struct HoleOpening;

struct IEspresso_Interface_v1 {
    CDUnknownFunctionPointerType *_vptr$IEspresso_Interface_v1;
    struct map<std::string, espresso_buffer_t *, std::less<std::string>, std::allocator<std::pair<const std::string, espresso_buffer_t *>>> _output_tensor;
    void *_ctx;
    void *_plan;
    CDStruct_2bc666a5 _net;
    struct basic_string<char, std::char_traits<char>, std::allocator<char>> _previous_mode;
    _Bool _single_resolution;
};

struct Inside_View<1UL> {
    struct Shape<1UL> _shape_of_view;
    struct Shape<1UL> _stride_of_view;
    unsigned long long _length_of_view;
    unsigned long long _offset_of_view;
};

struct Inside_View<2UL> {
    struct Shape<2UL> _shape_of_view;
    struct Shape<2UL> _stride_of_view;
    unsigned long long _length_of_view;
    unsigned long long _offset_of_view;
};

struct Inside_View<3UL> {
    struct Shape<3UL> _shape_of_view;
    struct Shape<3UL> _stride_of_view;
    unsigned long long _length_of_view;
    unsigned long long _offset_of_view;
};

struct Lcnn_FC2 {
    CDUnknownFunctionPointerType *_vptr$Lcnn_FC2;
    struct Tensor<float, 2UL> _fc2_0_weight;
    struct Tensor<float, 2UL> _fc2_1_weight;
    struct Tensor<float, 2UL> _fc2_2_weight;
    struct Tensor<float, 1UL> _fc2_0_bias;
    struct Tensor<float, 1UL> _fc2_1_bias;
    struct Tensor<float, 1UL> _fc2_2_bias;
    int _fc_dim;
    int _fc_dim1;
};

struct Lcnn_Floorplan_Post {
    float *density_buffer;
    struct lcnn_lines lcnn_lines;
    struct lcnn_juncs lcnn_juncs;
    struct PostProcess_Param _param;
};

struct Lcnn_floorplan_detector {
    CDUnknownFunctionPointerType *_vptr$Lcnn_floorplan_detector;
    struct Unet_fpn_backbone_v1 _unet_fpn_backbone;
    struct Lcnn_Floorplan_Post _wall_postprocess;
    struct Lcnn_Floorplan_Post _opening_postprocess;
    struct Tensor<float, 2UL> _wall_lmap;
    struct Tensor<float, 3UL> _lmap;
};

struct LightCoaching {
    float _kpt_range;
    float _threshold;
    struct deque<float, std::allocator<float>> _score_queue;
    struct deque<float, std::allocator<float>> _smooth_queue;
    float _latest_mean_color;
    float _latest_n_kpt;
    struct CoachingModel _model;
};

struct Line<float __attribute__((ext_vector_type(2)))> {
    MISSING_TYPE *corners[2];
};

struct Line<float __attribute__((ext_vector_type(3)))> {
    MISSING_TYPE *corners[2];
};

struct LineGeneration {
    CDUnknownFunctionPointerType *_vptr$LineGeneration;
    struct HeightLineFit height_fit;
    int gt_width;
};

struct MULTI_ROOM_CONFIG {
    float dist_thres;
    float iou_thres;
    float angle_thres;
    float angle_thres_for_small_walls;
    float small_wall_length_thres;
    float corner_dist_thres;
    float overlap_angle_thres;
    float overlap_dist_thres;
    float overlap_iou_thres;
    float overlap_min_line_length;
    float acute_angle_thres;
    float shorten_len_thr;
    float one_vs_two_shorten_len_thr;
    float line_equation_thres;
    float parallel_angle_thres;
    float identical_length_eps;
    float identical_dist_eps;
    float identical_overlap_iou_thres;
    float identical_length_eps_door;
    float identical_dist_eps_door;
    float identical_overlap_iou_thres_door;
    float overlap_iou_thres_door;
    float overlap_dist_thres_door;
    float identical_length_eps_window;
    float identical_dist_eps_windor;
    float identical_overlap_iou_thres_window;
    float overlap_angle_thres_window;
    float overlap_iou_thres_window;
    float overlap_dist_thres_window;
    float overlap_height_thres_window;
    float clustering_dist_threshold;
    float manhattan_wall_diff_threshold;
    float normal_shift_threshold;
    float internal_wall_thickness_threshold;
    float internal_wall_min_thickness_threshold;
    float z_shape_anchor_wall_threshold;
    float z_shape_wall_angle_diff_threshold;
    float merged_normal_angle_difference_threshold;
    float global_wall_height_ceiling_threshold;
    float global_wall_height_floor_threshold;
    float polygon_quads_iou_clear_threshold;
    float polygon_quads_corner_xy_dist_threshold;
    float polygon_quads_corner_z_dist_threshold;
    float polygon_corner_z_diff_threshold;
    float floor_clustering_update_ratio_threshold;
    float room_type_polygon_iou_merge_threshold;
    float max_height_diff_to_upper_level_floor;
    float height_gap_to_upper_level_floor;
    float min_length_for_principal_direction;
    float max_wall_angle_diff_for_principal_direction;
    float max_room_angle_diff_for_principal_direction;
    float max_length_for_non_connected_tiny_wall;
    float max_outlier_room_xy_distance;
    float max_outlier_room_height_distance;
    float min_ratio_for_outlier_room;
    float max_angle_for_rooms_with_overlap;
    float min_ratio_for_different_angle_in_same_level_room;
    float min_overlap_threshold_for_different_angle_rooms;
    float min_room_intersection_ratio_in_same_level;
    float min_room_polygon_overlap_ratio_in_same_level;
    float min_room_wall_merge_ratio_in_same_level;
};

struct MarkerProposal {
    CDUnknownFunctionPointerType *_vptr$MarkerProposal;
    float _extend_length;
    float _angle_thres_for_major_wall;
    float _parallel_angle_thres;
    float _corner_dist_thres;
    struct Structure_complete _alg_structure_complete;
    struct vector<marker_proposal::ProposalWrapper, std::allocator<marker_proposal::ProposalWrapper>> _pool;
    struct vector<std::vector<float __attribute__((ext_vector_type(3)))>, std::allocator<std::vector<float __attribute__((ext_vector_type(3)))>>> _all_major_convex_hulls;
};

struct Mat {
    int rows;
    int cols;
    double *data;
};

struct MergerForDoorWindow {
    CDUnknownFunctionPointerType *_vptr$MergerForDoorWindow;
    NSMutableArray *_new_instances;
    NSArray *_target_infer_walls_openings;
    NSArray *_new_walls_openings;
    NSMutableArray *_merged_instances;
    NSMutableArray *_prev_instances;
    NSMutableArray *_prev_instances_on_infer_walls_openings;
    NSMutableArray *_prev_instances_to_keep;
};

struct OBBDetector {
    struct optional<float __attribute__((ext_vector_type(2)))> _prev_main_vec;
};

struct ONLINE_BAY_WINDOW_CONFIG {
    float major_fov_angle_thres;
    float major_fov_angle_thres_buffer;
    float dist_thres;
    float iou_thres;
    float angle_thres;
    float angle_thres_for_small_walls;
    float small_wall_length_thres;
    float corner_dist_thres;
    float overlap_angle_thres;
    float overlap_dist_thres;
    float overlap_iou_thres;
    float acute_angle_thres;
    float shorten_len_thr;
    float one_vs_two_shorten_len_thr;
    int shorten_non_match_thr;
    float iou_thres_opening;
    int standalone_opening_thr;
    float hold_score_thres;
    float hold_small_wall_length_thres;
    float opening_checking_range;
    float opening_checking_thres;
    float opening_checking_occlusion_range;
    float min_length_thres;
    float parallel_angle_epsilon;
    float dup_dist_thr;
    float dup_angle_thr;
    float dup_iou_thr;
    float curved_wall_early_stop_score_thr;
    float low_conf_wall_score_thr;
    int low_conf_wall_non_match_thr;
};

struct ONLINE_CONFIG {
    float major_fov_angle_thres;
    float major_fov_angle_thres_buffer;
    float dist_thres;
    float iou_thres;
    float angle_thres;
    float angle_thres_for_small_walls;
    float small_wall_length_thres;
    float corner_dist_thres;
    float overlap_angle_thres;
    float overlap_dist_thres;
    float overlap_iou_thres;
    float acute_angle_thres;
    float shorten_len_thr;
    float one_vs_two_shorten_len_thr;
    int shorten_non_match_thr;
    float iou_thres_opening;
    int standalone_opening_thr;
    float hold_score_thres;
    float hold_small_wall_length_thres;
    float opening_checking_range;
    float opening_checking_thres;
    float opening_checking_occlusion_range;
    float min_length_thres;
    float parallel_angle_epsilon;
    float dup_dist_thr;
    float dup_angle_thr;
    float dup_iou_thr;
    float curved_wall_early_stop_score_thr;
    float low_conf_wall_score_thr;
    int low_conf_wall_non_match_thr;
};

struct ONLINE_CURVED_CONFIG {
    float minDist;
    int param1;
    int param2;
    float minRadius;
    float maxRadius;
    float density_thres;
    float angle_thres;
    float length_thres;
    int kernel_size;
    float iou_thr;
    float min_iou_thr;
    float dist_thr;
    float inner_line_tol;
    float inner_circle_tol;
    float intersect_tol;
    int segment_type;
    float segment_angle;
    float segment_length;
    float direction_change_eps;
    float reuse_uuid_iou_thr;
    float reuse_uuid_dist_thr;
    float reuse_uuid_angle_thr;
};

struct ONLINE_REFINE_CONFIG {
    int density_index;
    float slice_threshold;
    float min_slice_num;
    float min_wall_length;
    float min_density;
    float zslice_density_threshold;
    float major_small_wall_length_th;
};

struct ONLINE_STANDARDIZATION_CONFIG {
    float large_wall_len_thr;
    float small_wall_len_thr;
    float noise_wall_len_thr;
    float angle_thr;
    float noise_wall_angle_thr;
    float angle_eps;
    float anchor_wall_len_factor;
    float corner_dist_thr;
};

struct ONLINE_STRUCTURE_CONFIG {
    float z_shape_min_len;
    float z_shape_max_len;
    float w_shape_min_len;
    float w_shape_max_len;
};

struct OnboardCoaching {
    float _v_thr1;
    float _v_thr2;
    float _w_thr1;
    float _w_thr2;
    float _brightness_thr1;
    float _brightness_thr2;
    float _distance_thr1;
    float _distance_thr2;
    float _n_kpt_thr1;
    float _n_kpt_thr2;
    struct deque<float, std::allocator<float>> _texture_score_queue;
    struct deque<float, std::allocator<float>> _speed_score_queue;
    NSDate *_firstCallTime;
    RSTextCoachingSignal *_latest_signal;
    float _w_v;
    float _b_v;
    float _w_w;
    float _b_w;
    float _w_brightness;
    float _b_brightness;
    float _w_distance;
    float _b_distance;
    float _w_n_kpt;
    float _b_n_kpt;
};

struct OpeningHeightAlignment {
    CDUnknownFunctionPointerType *_vptr$OpeningHeightAlignment;
    struct unordered_map<std::string, rs_oalign::OpeningFixedNode, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, rs_oalign::OpeningFixedNode>>> _opening_fixed;
    _Bool _check_in_view;
    float _floor_v;
    float Min_Opening_height;
    float Invaid_height_min;
    int Max_try_times;
    int Second_try_times;
    float Max_opeing_height;
    double opening_wall_gap;
    struct vector<rs_oalign::HoleOpening, std::allocator<rs_oalign::HoleOpening>> _hole_vector;
};

struct Path3D;

struct PathFusion {
    CDUnknownFunctionPointerType *_vptr$PathFusion;
    float height_diff_thr;
    float slanted_seg_len_thr;
    struct map<std::string, int, std::less<std::string>, std::allocator<std::pair<const std::string, int>>> _skip_stat_dict;
};

struct PostProcess_Param {
    unsigned long long image_sz;
    float pixel_m;
    int max_length;
    float small_wall_length_thres;
    float length_score_weight;
    unsigned long long tm_score_protect_size;
    float tm_score_weight;
    struct map<std::vector<float>, unsigned long, std::less<std::vector<float>>, std::allocator<std::pair<const std::vector<float>, unsigned long>>> tm_score_line_width_map;
    float line_nms_angle_thres;
    float line_nms_dist_thres;
    float line_nms_sw_angle_thres;
    float line_nms_projection_iou_thres;
    float line_nms_score_diff_thres;
    struct map<std::vector<float>, std::vector<std::vector<float>>, std::less<std::vector<float>>, std::allocator<std::pair<const std::vector<float>, std::vector<std::vector<float>>>>> score_filtering_decision_boundary_map;
    float cls_delta;
    float tms_delta;
    struct map<std::vector<float>, std::vector<std::vector<float>>, std::less<std::vector<float>>, std::allocator<std::pair<const std::vector<float>, std::vector<std::vector<float>>>>> score_filtering_decision_boundary_map_for_line_proposals;
    float structure_filtering_acute_angle_min_thres;
    float structure_filtering_acute_angle_max_thres;
    float opening_score_density_thres;
    struct map<std::vector<float>, unsigned long, std::less<std::vector<float>>, std::allocator<std::pair<const std::vector<float>, unsigned long>>> opening_score_line_width_map;
    float hard_mode_opening_area_len_thres;
};

struct ProposalWrapper;

struct RS3DSurfaceOnline {
    CDUnknownFunctionPointerType *_vptr$RS3DSurfaceOnline;
    RS3DSurface *surface;
    struct Line<float __attribute__((ext_vector_type(2)))> line_2d;
    struct Line<float __attribute__((ext_vector_type(3)))> line_3d;
    float floor_height;
    float ceiling_height;
    float height;
    _Bool visible;
    _Bool visible_buffer;
    float major_dist;
    float major_angle;
    int transition_status;
    int first_appear_frame;
    int last_appear_frame;
    int non_match_count;
    int non_match_shorten_count;
    int debug_idx;
    int wall_type;
    int standalone_opening_count;
    _Bool is_bay_window_wall;
    struct basic_string<char, std::char_traits<char>, std::allocator<char>> _uuid;
    struct basic_string<char, std::char_traits<char>, std::allocator<char>> _parrent_uuid;
};

struct RSCurvedSurfaceOnline;

struct RSDeduplicateOpeningOpenDoorCore {
    CDUnknownFunctionPointerType *_vptr$RSDeduplicateOpeningOpenDoorCore;
    float _angle_thresh;
    float _projection_dist_thresh;
    float _dist_thresh;
    struct ONLINE_CONFIG _matching_config;
};

struct RSDriftDetectionCore {
    CDUnknownFunctionPointerType *_vptr$RSDriftDetectionCore;
    _Bool _is_arTrackingStable;
    _Bool _is_vioTrackingStable;
    _Bool _is_first_wall_generated;
    _Bool _is_first_keyframe_generated;
    _Bool _enable_sample_colors;
    struct vector<rs_drift_detection::DriftFrameInternalWraper, std::allocator<rs_drift_detection::DriftFrameInternalWraper>> _ar_frames;
    struct DRIFT_DETECTION_CONFIG _drift_detection_config;
    unsigned long long _count_idx;
    unsigned long long _ignore_idx;
    unsigned long long _keep_frame_size;
    unsigned long long _n_lost_track;
};

struct RSFloorPlanOnline {
    CDUnknownFunctionPointerType *_vptr$RSFloorPlanOnline;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> walls;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> openings;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> windows;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> doors;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> open_doors;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> door_panels;
    struct vector<RS3DCurvedSurface *, std::allocator<RS3DCurvedSurface *>> curved_circles;
    struct RSStructureGraph structure_graph;
    struct RS3DSurfaceOnline _empty;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> _empty_lists;
};

struct RSLocalStandardization {
    CDUnknownFunctionPointerType *_vptr$RSLocalStandardization;
    struct ONLINE_STANDARDIZATION_CONFIG _online_std_config;
    struct ONLINE_CONFIG _online_config;
};

struct RSOnlineFusion {
    CDUnknownFunctionPointerType *_vptr$RSOnlineFusion;
    struct vector<float __attribute__((ext_vector_type(3))), std::allocator<float __attribute__((ext_vector_type(3)))>> _camera_positions;
    _Bool _is_curved_wall_enabled;
    struct RSFloorPlanOnline _online_floorplan_last;
    struct ONLINE_CONFIG _online_config;
    struct ONLINE_STRUCTURE_CONFIG _structure_config;
    struct RSTmOnlineTMScoreHelper _tm_helper;
    struct RSLocalStandardization _local_standardization;
    struct vector<rs_ol::RSCurvedSurfaceOnline, std::allocator<rs_ol::RSCurvedSurfaceOnline>> _curved_walls;
    struct vector<RS3DCurvedSurface *, std::allocator<RS3DCurvedSurface *>> _online_curved_segments;
    struct ONLINE_CURVED_CONFIG _online_curved_wall_config;
    _Bool _need_curved_wall_process;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> _historical_low_conf_walls;
};

struct RSOnlineOfflineAssociationCore {
    CDUnknownFunctionPointerType *_vptr$RSOnlineOfflineAssociationCore;
    struct ONLINE_CONFIG _offline_config;
    _Bool _is_curve_enabled;
};

struct RSOnlineRefinement {
    CDUnknownFunctionPointerType *_vptr$RSOnlineRefinement;
    struct Tensor<int, 3UL> _search_range_7;
    struct Tensor<int, 3UL> _search_range_3;
    struct optional<rs_ol::RS3DSurfaceOnline> _fitting_lines;
    struct ONLINE_REFINE_CONFIG _config;
    struct ONLINE_CONFIG _online_config;
};

struct RSParentAssociationCore {
    CDUnknownFunctionPointerType *_vptr$RSParentAssociationCore;
    struct ONLINE_CONFIG _matching_config;
};

struct RSStructure;

struct RSStructureGraph {
    CDUnknownFunctionPointerType *_vptr$RSStructureGraph;
    struct vector<rs_ol::RSStructure *, std::allocator<rs_ol::RSStructure *>> _structures;
};

struct RSTmOnlineTMScoreHelper {
    CDUnknownFunctionPointerType *_vptr$RSTmOnlineTMScoreHelper;
};

struct RS_Match_Info;

struct RelationItem;

struct RoomTypeConfig {
    unsigned long long img_sz;
    float pixel_sz;
    unsigned long long input_channel;
    unsigned long long z_slice;
    _Bool dynamic_pixel_sz;
    struct vector<std::string, std::allocator<std::string>> model_input_names;
    struct vector<roomscancore::roomtype_v4::RoomTypeCategory, std::allocator<roomscancore::roomtype_v4::RoomTypeCategory>> model_output_categories;
    struct vector<std::string, std::allocator<std::string>> model_output_names;
    struct basic_string<char, std::char_traits<char>, std::allocator<char>> model_name;
    struct vector<unsigned long, std::allocator<unsigned long>> model_input_shape;
    struct vector<unsigned long, std::allocator<unsigned long>> model_output_shape;
    struct unordered_map<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::allocator<std::pair<const roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>>> area_thr;
    struct unordered_map<roomscancore::roomtype_v4::RoomTypeCategory, float, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::allocator<std::pair<const roomscancore::roomtype_v4::RoomTypeCategory, float>>> score_thr;
    struct unordered_map<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::allocator<std::pair<const roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>>> obj_config;
};

struct RoomTypeDetector {
    struct IEspresso_Interface_v1 model_;
    struct RoomTypeConfig cfg_;
};

struct Room_Standardization {
    struct StandardFloorPlan standardizer_;
    struct unordered_map<std::string, std::vector<wlw::lcnn_flp::ProjectParam>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, std::vector<wlw::lcnn_flp::ProjectParam>>>> project_map_;
    struct RSLocalStandardization localStandardizer_;
};

struct Shape<1UL> {
    unsigned long long _sp[6];
};

struct Shape<2UL> {
    unsigned long long _sp[6];
};

struct Shape<3UL> {
    unsigned long long _sp[6];
};

struct Simplification;

struct SpeedCoaching {
    float _speed_range;
    float _proj_speed_range;
    float _threshold;
    struct deque<std::tuple<simd_float4x4, double>, std::allocator<std::tuple<simd_float4x4, double>>> _pose_queue;
    struct deque<float, std::allocator<float>> _score_queue;
    struct deque<float __attribute__((ext_vector_type(2))), std::allocator<float __attribute__((ext_vector_type(2)))>> _smooth_queue;
    NSDate *_latest_v___latest_w___last_vio_lost_time;
    struct CoachingModel _model;
};

struct StandardFloorPlan {
    struct Standard_Param param_;
    struct vector<roomscancore::Line<float __attribute__((ext_vector_type(2)))>, std::allocator<roomscancore::Line<float __attribute__((ext_vector_type(2)))>>> walls;
    struct vector<float __attribute__((ext_vector_type(2))), std::allocator<float __attribute__((ext_vector_type(2)))>> vertex;
    struct vector<float, std::allocator<float>> vertex_1d;
    struct vector<std::vector<unsigned long>, std::allocator<std::vector<unsigned long>>> line_mask;
    struct vector<std::vector<unsigned long>, std::allocator<std::vector<unsigned long>>> vertex_walls;
    struct vector<float, std::allocator<float>> vertex_angles;
    struct vector<float, std::allocator<float>> vertex_angles_180;
    struct vector<unsigned long, std::allocator<unsigned long>> tiny_sw_vertex;
    struct vector<unsigned long, std::allocator<unsigned long>> tiny_sw_line_id;
    struct vector<float, std::allocator<float>> scores;
    struct Line<float __attribute__((ext_vector_type(2)))> first_wall;
    struct GeometryMeta geo_meta_;
    struct Tensor<float, 2UL> density_map_;
    struct vector<float, std::allocator<float>> before_tm_scores_;
};

struct Standard_Param {
    float pixel_sz_dynamic;
    int init_minimum_walls;
    float shortest_wall_length;
    float duplicate_point_thresh;
    float unique_point_angle;
    float tiny_small_wall_length;
    float parallel_dis_thresh;
    float parallel_angle_thresh;
    float lbfgs_drift_angle_thresh;
    float lbfgs_dist_thresh;
    float lbfgs_optimize_min_length;
    float lbfgs_move_region;
    float lbfgs_move_region_rate;
    float lbfgs_tm_score_diff_thresh;
    float min_first_wall_length;
    float manhattan_angle_offset;
    float keep_connect_angle_thresh;
    float keep_connect_intersection_distance;
    float need_rotate_small_wall_length;
    float need_rotate_wall_angle;
    float need_rotate_small_wall_angle;
    float standard_manhattan_angle;
    float merge_cross_lines_dis_thresh;
    float merge_cross_lines_angle_thresh;
    float merge_cross_lines_split_dist_th;
    float merge_cross_gap_dist_th;
    float merge_cross_gap_angle_th;
    float add_tiny_corner_dist_th;
    float add_tiny_corner_vertical_angle_th;
    float add_tiny_corner_parallel_angle_th;
    float add_tiny_opening_dist_th;
    float add_tiny_opening_parallel_angle_th;
    float add_tiny_opening_parallel_dist_th;
};

struct Structure_complete {
    struct vector<marker_proposal::Structure_completeOutput, std::allocator<marker_proposal::Structure_completeOutput>> small_gaps;
    struct vector<marker_proposal::Structure_completeOutput, std::allocator<marker_proposal::Structure_completeOutput>> small_gaps_result;
    float _connection_angle_thresh;
    float _gap_length_thresh;
    float _gap_size_thresh;
    float _iou_thresh;
    float _line_occupancy_thresh;
    float _angle_thres_with_view_line;
    float _neighbor_line_threshold;
    int _frame_in_consider;
    int _line_id1;
    int _line_id2;
};

struct Structure_completeOutput;

struct Tensor<float, 1UL> {
    CDUnknownFunctionPointerType *_vptr$Tensor;
    struct Inside_View<1UL> _view;
    struct shared_ptr<wt::Storage<float>> _storage;
    _Bool _is_contiguous;
    _Bool _is_empty;
    float *_buffer_head;
};

struct Tensor<float, 2UL> {
    CDUnknownFunctionPointerType *_vptr$Tensor;
    struct Inside_View<2UL> _view;
    struct shared_ptr<wt::Storage<float>> _storage;
    _Bool _is_contiguous;
    _Bool _is_empty;
    float *_buffer_head;
};

struct Tensor<float, 3UL> {
    CDUnknownFunctionPointerType *_vptr$Tensor;
    struct Inside_View<3UL> _view;
    struct shared_ptr<wt::Storage<float>> _storage;
    _Bool _is_contiguous;
    _Bool _is_empty;
    float *_buffer_head;
};

struct Tensor<int, 3UL> {
    CDUnknownFunctionPointerType *_vptr$Tensor;
    struct Inside_View<3UL> _view;
    struct shared_ptr<wt::Storage<int>> _storage;
    _Bool _is_contiguous;
    _Bool _is_empty;
    int *_buffer_head;
};

struct TracingMap {
    CDUnknownFunctionPointerType *_vptr$TracingMap;
    float _voxel_sz;
    struct unordered_map<unsigned long long, bool, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<std::pair<const unsigned long long, bool>>> _values;
};

struct Unet_fpn_backbone_v1 {
    CDUnknownFunctionPointerType *_vptr$Unet_fpn_backbone_v1;
    struct IEspresso_Interface_v1 _net;
    struct Lcnn_FC2 _lcnn_fc2;
    struct Tensor<float, 2UL> _lambda;
    struct BackBone_Param _backbone_param;
};

struct WallOpeningAttribute;

struct WallOpeningSelectorForDoorWindow {
    CDUnknownFunctionPointerType *_vptr$WallOpeningSelectorForDoorWindow;
    NSMutableArray *_infer_wall_openings;
    struct vector<wlw_olp::WallOpeningAttribute, std::allocator<wlw_olp::WallOpeningAttribute>> _infer_wall_openings_attributes;
    NSMutableArray *_target_infer_wall_openings;
    struct vector<wlw_olp::WallOpeningAttribute, std::allocator<wlw_olp::WallOpeningAttribute>> _target_infer_wall_openings_attributes;
    NSArray *_new_wall_openings;
    id _cur_keyframe;
    float _floor_height;
    float _ceiling_height;
    void *_convex_hull;
    unsigned long long _convex_hull_size;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> _cur_lines;
    struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> _new_lines;
    struct vector<rshape::RS_Match_Info, std::allocator<rshape::RS_Match_Info>> _cur_matches;
    struct vector<rshape::RS_Match_Info, std::allocator<rshape::RS_Match_Info>> _new_matches;
    _Bool _select_wall;
};

struct __shared_weak_count;

struct __tree_end_node<std::__tree_node_base<void *>*> {
    void *__left_;
};

struct basic_string<char, std::char_traits<char>, std::allocator<char>> {
    struct __compressed_pair<std::basic_string<char>::__rep, std::allocator<char>> {
        struct __rep {
            union {
                struct __long {
                    struct {
                        unsigned int __is_long_:1;
                        unsigned int __cap_:63;
                    } ;
                    unsigned long long __size_;
                    char *__data_;
                } __l;
                struct __short {
                    struct {
                        unsigned int __is_long_:1;
                        unsigned int __size_:7;
                    } ;
                    char __padding_[0];
                    char __data_[23];
                } __s;
                struct __raw {
                    unsigned long long __words[3];
                } __r;
            } ;
        } __value_;
    } __r_;
};

struct deque<float __attribute__((ext_vector_type(2))), std::allocator<float __attribute__((ext_vector_type(2)))>> {
    struct __split_buffer<float * __attribute__((ext_vector_type(2))), std::allocator<float * __attribute__((ext_vector_type(2)))>> {
        void **__first_;
        void **__begin_;
        void **__end_;
        struct __compressed_pair<float ** __attribute__((ext_vector_type(2))), std::allocator<float * __attribute__((ext_vector_type(2)))>> {
            void **__value_;
        } __end_cap_;
    } __map_;
    unsigned long long __start_;
    struct __compressed_pair<unsigned long, std::allocator<float __attribute__((ext_vector_type(2)))>> {
        unsigned long long __value_;
    } __size_;
};

struct deque<float, std::allocator<float>> {
    struct __split_buffer<float *, std::allocator<float *>> {
        float **__first_;
        float **__begin_;
        float **__end_;
        struct __compressed_pair<float **, std::allocator<float *>> {
            float **__value_;
        } __end_cap_;
    } __map_;
    unsigned long long __start_;
    struct __compressed_pair<unsigned long, std::allocator<float>> {
        unsigned long long __value_;
    } __size_;
};

struct deque<std::tuple<simd_float4x4, double>, std::allocator<std::tuple<simd_float4x4, double>>> {
    struct __split_buffer<std::tuple<simd_float4x4, double>*, std::allocator<std::tuple<simd_float4x4, double>*>> {
        void **__first_;
        void **__begin_;
        void **__end_;
        struct __compressed_pair<std::tuple<simd_float4x4, double>**, std::allocator<std::tuple<simd_float4x4, double>*>> {
            void **__value_;
        } __end_cap_;
    } __map_;
    unsigned long long __start_;
    struct __compressed_pair<unsigned long, std::allocator<std::tuple<simd_float4x4, double>>> {
        unsigned long long __value_;
    } __size_;
};

struct lcnn_juncs {
    struct vector<float __attribute__((ext_vector_type(2))), std::allocator<float __attribute__((ext_vector_type(2)))>> juncs;
    struct vector<float, std::allocator<float>> junc_scores;
    unsigned long long num_juncs;
};

struct lcnn_lines {
    struct vector<roomscancore::Line<float __attribute__((ext_vector_type(2)))>, std::allocator<roomscancore::Line<float __attribute__((ext_vector_type(2)))>>> lines;
    struct vector<float, std::allocator<float>> scores;
    unsigned long long num_lines;
};

struct map<std::string, espresso_buffer_t *, std::less<std::string>, std::allocator<std::pair<const std::string, espresso_buffer_t *>>> {
    struct __tree<std::__value_type<std::string, espresso_buffer_t *>, std::__map_value_compare<std::string, std::__value_type<std::string, espresso_buffer_t *>, std::less<std::string>>, std::allocator<std::__value_type<std::string, espresso_buffer_t *>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::string, espresso_buffer_t *>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::string, std::__value_type<std::string, espresso_buffer_t *>, std::less<std::string>>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct map<std::string, int, std::less<std::string>, std::allocator<std::pair<const std::string, int>>> {
    struct __tree<std::__value_type<std::string, int>, std::__map_value_compare<std::string, std::__value_type<std::string, int>, std::less<std::string>>, std::allocator<std::__value_type<std::string, int>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::string, int>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::string, std::__value_type<std::string, int>, std::less<std::string>>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct map<std::vector<float>, std::vector<std::vector<float>>, std::less<std::vector<float>>, std::allocator<std::pair<const std::vector<float>, std::vector<std::vector<float>>>>> {
    struct __tree<std::__value_type<std::vector<float>, std::vector<std::vector<float>>>, std::__map_value_compare<std::vector<float>, std::__value_type<std::vector<float>, std::vector<std::vector<float>>>, std::less<std::vector<float>>>, std::allocator<std::__value_type<std::vector<float>, std::vector<std::vector<float>>>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::vector<float>, std::vector<std::vector<float>>>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::vector<float>, std::__value_type<std::vector<float>, std::vector<std::vector<float>>>, std::less<std::vector<float>>>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct map<std::vector<float>, unsigned long, std::less<std::vector<float>>, std::allocator<std::pair<const std::vector<float>, unsigned long>>> {
    struct __tree<std::__value_type<std::vector<float>, unsigned long>, std::__map_value_compare<std::vector<float>, std::__value_type<std::vector<float>, unsigned long>, std::less<std::vector<float>>>, std::allocator<std::__value_type<std::vector<float>, unsigned long>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::vector<float>, unsigned long>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::vector<float>, std::__value_type<std::vector<float>, unsigned long>, std::less<std::vector<float>>>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct map<std::vector<unsigned long>, std::string, std::less<std::vector<unsigned long>>, std::allocator<std::pair<const std::vector<unsigned long>, std::string>>> {
    struct __tree<std::__value_type<std::vector<unsigned long>, std::string>, std::__map_value_compare<std::vector<unsigned long>, std::__value_type<std::vector<unsigned long>, std::string>, std::less<std::vector<unsigned long>>>, std::allocator<std::__value_type<std::vector<unsigned long>, std::string>>> {
        void *__begin_node_;
        struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *>*>, std::allocator<std::__tree_node<std::__value_type<std::vector<unsigned long>, std::string>, void *>>> {
            struct __tree_end_node<std::__tree_node_base<void *>*> __value_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__map_value_compare<std::vector<unsigned long>, std::__value_type<std::vector<unsigned long>, std::string>, std::less<std::vector<unsigned long>>>> {
            unsigned long long __value_;
        } __pair3_;
    } __tree_;
};

struct mutex {
    struct _opaque_pthread_mutex_t {
        long long __sig;
        char __opaque[56];
    } __m_;
};

struct optional<float __attribute__((ext_vector_type(2)))> {
    union {
        char __null_state_;
        MISSING_TYPE *__val_;
    } ;
    _Bool __engaged_;
};

struct optional<rs_ol::RS3DSurfaceOnline> {
    union {
        char __null_state_;
        struct RS3DSurfaceOnline __val_;
    } ;
    _Bool __engaged_;
};

struct shared_ptr<wt::Storage<float>> {
    void *__ptr_;
    struct __shared_weak_count *__cntrl_;
};

struct shared_ptr<wt::Storage<int>> {
    void *__ptr_;
    struct __shared_weak_count *__cntrl_;
};

struct unique_ptr<rs_erf::EdgeRefinement, std::default_delete<rs_erf::EdgeRefinement>> {
    struct __compressed_pair<rs_erf::EdgeRefinement *, std::default_delete<rs_erf::EdgeRefinement>> {
        struct EdgeRefinement *__value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unique_ptr<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>*>>> {
    struct __compressed_pair<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>**, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>*>>> {
        void **__value_;
        struct __bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>*>> {
            struct __compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>*>> {
                unsigned long long __value_;
            } __data_;
        } __value_;
    } __ptr_;
};

struct unordered_map<int, int, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<const int, int>>> {
    struct __hash_table<std::__hash_value_type<int, int>, std::__unordered_map_hasher<int, std::__hash_value_type<int, int>, std::hash<int>, std::equal_to<int>>, std::__unordered_map_equal<int, std::__hash_value_type<int, int>, std::equal_to<int>, std::hash<int>>, std::allocator<std::__hash_value_type<int, int>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<int, int>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<int, int>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<int, std::__hash_value_type<int, int>, std::hash<int>, std::equal_to<int>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<int, std::__hash_value_type<int, int>, std::equal_to<int>, std::hash<int>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<roomscancore::roomtype_v4::RoomTypeCategory, float, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::allocator<std::pair<const roomscancore::roomtype_v4::RoomTypeCategory, float>>> {
    struct __hash_table<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, std::__unordered_map_hasher<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>>, std::__unordered_map_equal<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>>, std::allocator<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, float>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::allocator<std::pair<const roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>>> {
    struct __hash_table<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, std::__unordered_map_hasher<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>>, std::__unordered_map_equal<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>>, std::allocator<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, roomscancore::roomtype_v4::RoomObjectConstraint>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::allocator<std::pair<const roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>>> {
    struct __hash_table<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, std::__unordered_map_hasher<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>>, std::__unordered_map_equal<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>>, std::allocator<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<roomscancore::roomtype_v4::RoomTypeCategory, std::__hash_value_type<roomscancore::roomtype_v4::RoomTypeCategory, unsigned long>, std::equal_to<roomscancore::roomtype_v4::RoomTypeCategory>, std::hash<roomscancore::roomtype_v4::RoomTypeCategory>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<rs_ol::Relation_Type, std::vector<std::pair<int, int>>, std::hash<rs_ol::Relation_Type>, std::equal_to<rs_ol::Relation_Type>, std::allocator<std::pair<const rs_ol::Relation_Type, std::vector<std::pair<int, int>>>>> {
    struct __hash_table<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, std::__unordered_map_hasher<rs_ol::Relation_Type, std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, std::hash<rs_ol::Relation_Type>, std::equal_to<rs_ol::Relation_Type>>, std::__unordered_map_equal<rs_ol::Relation_Type, std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, std::equal_to<rs_ol::Relation_Type>, std::hash<rs_ol::Relation_Type>>, std::allocator<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<rs_ol::Relation_Type, std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, std::hash<rs_ol::Relation_Type>, std::equal_to<rs_ol::Relation_Type>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<rs_ol::Relation_Type, std::__hash_value_type<rs_ol::Relation_Type, std::vector<std::pair<int, int>>>, std::equal_to<rs_ol::Relation_Type>, std::hash<rs_ol::Relation_Type>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<std::pair<int, int>, std::vector<std::pair<int, int>>, (anonymous namespace)::pair_hash, std::equal_to<std::pair<int, int>>, std::allocator<std::pair<const std::pair<int, int>, std::vector<std::pair<int, int>>>>> {
    struct __hash_table<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, std::__unordered_map_hasher<std::pair<int, int>, std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, (anonymous namespace)::pair_hash, std::equal_to<std::pair<int, int>>>, std::__unordered_map_equal<std::pair<int, int>, std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, std::equal_to<std::pair<int, int>>, (anonymous namespace)::pair_hash>, std::allocator<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::pair<int, int>, std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, (anonymous namespace)::pair_hash, std::equal_to<std::pair<int, int>>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<std::pair<int, int>, std::__hash_value_type<std::pair<int, int>, std::vector<std::pair<int, int>>>, std::equal_to<std::pair<int, int>>, (anonymous namespace)::pair_hash>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<std::string, rs_oalign::OpeningFixedNode, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, rs_oalign::OpeningFixedNode>>> {
    struct __hash_table<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, std::hash<std::string>, std::equal_to<std::string>>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, std::equal_to<std::string>, std::hash<std::string>>, std::allocator<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, std::hash<std::string>, std::equal_to<std::string>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, rs_oalign::OpeningFixedNode>, std::equal_to<std::string>, std::hash<std::string>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<std::string, std::unordered_set<unsigned long long>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, std::unordered_set<unsigned long long>>>> {
    struct __hash_table<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, std::hash<std::string>, std::equal_to<std::string>>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, std::equal_to<std::string>, std::hash<std::string>>, std::allocator<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, std::hash<std::string>, std::equal_to<std::string>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, std::unordered_set<unsigned long long>>, std::equal_to<std::string>, std::hash<std::string>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<std::string, std::vector<wlw::lcnn_flp::ProjectParam>, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, std::vector<wlw::lcnn_flp::ProjectParam>>>> {
    struct __hash_table<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, std::hash<std::string>, std::equal_to<std::string>>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, std::equal_to<std::string>, std::hash<std::string>>, std::allocator<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, std::hash<std::string>, std::equal_to<std::string>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, std::vector<wlw::lcnn_flp::ProjectParam>>, std::equal_to<std::string>, std::hash<std::string>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<std::string, unsigned int __attribute__((ext_vector_type(2))), std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, unsigned int __attribute__((ext_vector_type(2)))>>> {
    struct __hash_table<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, std::hash<std::string>, std::equal_to<std::string>>, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, std::equal_to<std::string>, std::hash<std::string>>, std::allocator<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<std::string, std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, std::hash<std::string>, std::equal_to<std::string>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<std::string, std::__hash_value_type<std::string, unsigned int __attribute__((ext_vector_type(2)))>, std::equal_to<std::string>, std::hash<std::string>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_map<unsigned long long, bool, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<std::pair<const unsigned long long, bool>>> {
    struct __hash_table<std::__hash_value_type<unsigned long long, bool>, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, bool>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, bool>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>, std::allocator<std::__hash_value_type<unsigned long long, bool>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*>, std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::__hash_value_type<unsigned long long, bool>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__unordered_map_hasher<unsigned long long, std::__hash_value_type<unsigned long long, bool>, std::hash<unsigned long long>, std::equal_to<unsigned long long>>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::__unordered_map_equal<unsigned long long, std::__hash_value_type<unsigned long long, bool>, std::equal_to<unsigned long long>, std::hash<unsigned long long>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_set<std::pair<int, int>, (anonymous namespace)::pair_hash, std::equal_to<std::pair<int, int>>, std::allocator<std::pair<int, int>>> {
    struct __hash_table<std::pair<int, int>, (anonymous namespace)::pair_hash, std::equal_to<std::pair<int, int>>, std::allocator<std::pair<int, int>>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::pair<int, int>, void *>*>, std::allocator<std::__hash_node<std::pair<int, int>, void *>>> {
            struct __hash_node_base<std::__hash_node<std::pair<int, int>, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, (anonymous namespace)::pair_hash> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::equal_to<std::pair<int, int>>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_set<unsigned long long, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<unsigned long long>> {
    struct __hash_table<unsigned long long, std::hash<unsigned long long>, std::equal_to<unsigned long long>, std::allocator<unsigned long long>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<unsigned long long, void *>*>, std::allocator<std::__hash_node<unsigned long long, void *>>> {
            struct __hash_node_base<std::__hash_node<unsigned long long, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::hash<unsigned long long>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::equal_to<unsigned long long>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct unordered_set<unsigned long, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<unsigned long>> {
    struct __hash_table<unsigned long, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<unsigned long>> {
        struct unique_ptr<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>*[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>*>>> __bucket_list_;
        struct __compressed_pair<std::__hash_node_base<std::__hash_node<unsigned long, void *>*>, std::allocator<std::__hash_node<unsigned long, void *>>> {
            struct __hash_node_base<std::__hash_node<unsigned long, void *>*> {
                void *__next_;
            } __value_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::hash<unsigned long>> {
            unsigned long long __value_;
        } __p2_;
        struct __compressed_pair<float, std::equal_to<unsigned long>> {
            float __value_;
        } __p3_;
    } __table_;
};

struct vector<(anonymous namespace)::RelationItem, std::allocator<(anonymous namespace)::RelationItem>> {
    struct RelationItem *__begin_;
    struct RelationItem *__end_;
    struct __compressed_pair<(anonymous namespace)::RelationItem *, std::allocator<(anonymous namespace)::RelationItem>> {
        struct RelationItem *__value_;
    } __end_cap_;
};

struct vector<RS3DCurvedSurface *, std::allocator<RS3DCurvedSurface *>> {
    id *__begin_;
    id *__end_;
    struct __compressed_pair<RS3DCurvedSurface *__strong *, std::allocator<RS3DCurvedSurface *>> {
        id *__value_;
    } __end_cap_;
};

struct vector<float __attribute__((ext_vector_type(2))), std::allocator<float __attribute__((ext_vector_type(2)))>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<float * __attribute__((ext_vector_type(2))), std::allocator<float __attribute__((ext_vector_type(2)))>> {
        void *__value_;
    } __end_cap_;
};

struct vector<float __attribute__((ext_vector_type(3))), std::allocator<float __attribute__((ext_vector_type(3)))>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<float * __attribute__((ext_vector_type(3))), std::allocator<float __attribute__((ext_vector_type(3)))>> {
        void *__value_;
    } __end_cap_;
};

struct vector<float, std::allocator<float>> {
    float *__begin_;
    float *__end_;
    struct __compressed_pair<float *, std::allocator<float>> {
        float *__value_;
    } __end_cap_;
};

struct vector<int, std::allocator<int>> {
    int *__begin_;
    int *__end_;
    struct __compressed_pair<int *, std::allocator<int>> {
        int *__value_;
    } __end_cap_;
};

struct vector<marker_proposal::ProposalWrapper, std::allocator<marker_proposal::ProposalWrapper>> {
    struct ProposalWrapper *__begin_;
    struct ProposalWrapper *__end_;
    struct __compressed_pair<marker_proposal::ProposalWrapper *, std::allocator<marker_proposal::ProposalWrapper>> {
        struct ProposalWrapper *__value_;
    } __end_cap_;
};

struct vector<marker_proposal::Structure_completeOutput, std::allocator<marker_proposal::Structure_completeOutput>> {
    struct Structure_completeOutput *__begin_;
    struct Structure_completeOutput *__end_;
    struct __compressed_pair<marker_proposal::Structure_completeOutput *, std::allocator<marker_proposal::Structure_completeOutput>> {
        struct Structure_completeOutput *__value_;
    } __end_cap_;
};

struct vector<roomscancore::Line<float __attribute__((ext_vector_type(2)))>, std::allocator<roomscancore::Line<float __attribute__((ext_vector_type(2)))>>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<roomscancore::Line<float __attribute__((ext_vector_type(2)))>*, std::allocator<roomscancore::Line<float __attribute__((ext_vector_type(2)))>>> {
        void *__value_;
    } __end_cap_;
};

struct vector<roomscancore::nuh_model::post_type::Path3D, std::allocator<roomscancore::nuh_model::post_type::Path3D>> {
    struct Path3D *__begin_;
    struct Path3D *__end_;
    struct __compressed_pair<roomscancore::nuh_model::post_type::Path3D *, std::allocator<roomscancore::nuh_model::post_type::Path3D>> {
        struct Path3D *__value_;
    } __end_cap_;
};

struct vector<roomscancore::roomtype_v4::RoomTypeCategory, std::allocator<roomscancore::roomtype_v4::RoomTypeCategory>> {
    int *__begin_;
    int *__end_;
    struct __compressed_pair<roomscancore::roomtype_v4::RoomTypeCategory *, std::allocator<roomscancore::roomtype_v4::RoomTypeCategory>> {
        int *__value_;
    } __end_cap_;
};

struct vector<rs_drift_detection::DriftFrameInternalWraper, std::allocator<rs_drift_detection::DriftFrameInternalWraper>> {
    struct DriftFrameInternalWraper *__begin_;
    struct DriftFrameInternalWraper *__end_;
    struct __compressed_pair<rs_drift_detection::DriftFrameInternalWraper *, std::allocator<rs_drift_detection::DriftFrameInternalWraper>> {
        struct DriftFrameInternalWraper *__value_;
    } __end_cap_;
};

struct vector<rs_oalign::HoleOpening, std::allocator<rs_oalign::HoleOpening>> {
    struct HoleOpening *__begin_;
    struct HoleOpening *__end_;
    struct __compressed_pair<rs_oalign::HoleOpening *, std::allocator<rs_oalign::HoleOpening>> {
        struct HoleOpening *__value_;
    } __end_cap_;
};

struct vector<rs_ol::RS3DSurfaceOnline, std::allocator<rs_ol::RS3DSurfaceOnline>> {
    struct RS3DSurfaceOnline *__begin_;
    struct RS3DSurfaceOnline *__end_;
    struct __compressed_pair<rs_ol::RS3DSurfaceOnline *, std::allocator<rs_ol::RS3DSurfaceOnline>> {
        struct RS3DSurfaceOnline *__value_;
    } __end_cap_;
};

struct vector<rs_ol::RSCurvedSurfaceOnline, std::allocator<rs_ol::RSCurvedSurfaceOnline>> {
    struct RSCurvedSurfaceOnline *__begin_;
    struct RSCurvedSurfaceOnline *__end_;
    struct __compressed_pair<rs_ol::RSCurvedSurfaceOnline *, std::allocator<rs_ol::RSCurvedSurfaceOnline>> {
        struct RSCurvedSurfaceOnline *__value_;
    } __end_cap_;
};

struct vector<rs_ol::RSStructure *, std::allocator<rs_ol::RSStructure *>> {
    struct RSStructure **__begin_;
    struct RSStructure **__end_;
    struct __compressed_pair<rs_ol::RSStructure **, std::allocator<rs_ol::RSStructure *>> {
        struct RSStructure **__value_;
    } __end_cap_;
};

struct vector<rshape::RS_Match_Info, std::allocator<rshape::RS_Match_Info>> {
    struct RS_Match_Info *__begin_;
    struct RS_Match_Info *__end_;
    struct __compressed_pair<rshape::RS_Match_Info *, std::allocator<rshape::RS_Match_Info>> {
        struct RS_Match_Info *__value_;
    } __end_cap_;
};

struct vector<simd_float4x4, std::allocator<simd_float4x4>> {
    CDStruct_183601bc *__begin_;
    CDStruct_183601bc *__end_;
    struct __compressed_pair<simd_float4x4 *, std::allocator<simd_float4x4>> {
        CDStruct_183601bc *__value_;
    } __end_cap_;
};

struct vector<std::string, std::allocator<std::string>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::string *, std::allocator<std::string>> {
        void *__value_;
    } __end_cap_;
};

struct vector<std::tuple<float __attribute__((ext_vector_type(3))), float __attribute__((ext_vector_type(3))), RS3DSurfaceQuad>, std::allocator<std::tuple<float __attribute__((ext_vector_type(3))), float __attribute__((ext_vector_type(3))), RS3DSurfaceQuad>>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::tuple<float __attribute__((ext_vector_type(3))), float __attribute__((ext_vector_type(3))), RS3DSurfaceQuad>*, std::allocator<std::tuple<float __attribute__((ext_vector_type(3))), float __attribute__((ext_vector_type(3))), RS3DSurfaceQuad>>> {
        void *__value_;
    } __end_cap_;
};

struct vector<std::unordered_map<std::pair<int, int>, std::vector<std::pair<int, int>>, (anonymous namespace)::pair_hash>, std::allocator<std::unordered_map<std::pair<int, int>, std::vector<std::pair<int, int>>, (anonymous namespace)::pair_hash>>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::unordered_map<std::pair<int, int>, std::vector<std::pair<int, int>>, (anonymous namespace)::pair_hash>*, std::allocator<std::unordered_map<std::pair<int, int>, std::vector<std::pair<int, int>>, (anonymous namespace)::pair_hash>>> {
        void *__value_;
    } __end_cap_;
};

struct vector<std::unordered_set<int>, std::allocator<std::unordered_set<int>>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::unordered_set<int>*, std::allocator<std::unordered_set<int>>> {
        void *__value_;
    } __end_cap_;
};

struct vector<std::vector<float __attribute__((ext_vector_type(3)))>, std::allocator<std::vector<float __attribute__((ext_vector_type(3)))>>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::vector<float __attribute__((ext_vector_type(3)))>*, std::allocator<std::vector<float __attribute__((ext_vector_type(3)))>>> {
        void *__value_;
    } __end_cap_;
};

struct vector<std::vector<float>, std::allocator<std::vector<float>>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::vector<float>*, std::allocator<std::vector<float>>> {
        void *__value_;
    } __end_cap_;
};

struct vector<std::vector<std::vector<std::vector<std::vector<float>>>>, std::allocator<std::vector<std::vector<std::vector<std::vector<float>>>>>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::vector<std::vector<std::vector<std::vector<float>>>>*, std::allocator<std::vector<std::vector<std::vector<std::vector<float>>>>>> {
        void *__value_;
    } __end_cap_;
};

struct vector<std::vector<unsigned long>, std::allocator<std::vector<unsigned long>>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<std::vector<unsigned long>*, std::allocator<std::vector<unsigned long>>> {
        void *__value_;
    } __end_cap_;
};

struct vector<unsigned char __attribute__((ext_vector_type(4))), std::allocator<unsigned char __attribute__((ext_vector_type(4)))>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<unsigned char * __attribute__((ext_vector_type(4))), std::allocator<unsigned char __attribute__((ext_vector_type(4)))>> {
        void *__value_;
    } __end_cap_;
};

struct vector<unsigned long, std::allocator<unsigned long>> {
    unsigned long long *__begin_;
    unsigned long long *__end_;
    struct __compressed_pair<unsigned long *, std::allocator<unsigned long>> {
        unsigned long long *__value_;
    } __end_cap_;
};

struct vector<unsigned short __attribute__((ext_vector_type(4))), std::allocator<unsigned short __attribute__((ext_vector_type(4)))>> {
    void *__begin_;
    void *__end_;
    struct __compressed_pair<unsigned short * __attribute__((ext_vector_type(4))), std::allocator<unsigned short __attribute__((ext_vector_type(4)))>> {
        void *__value_;
    } __end_cap_;
};

struct vector<wlw_olp::WallOpeningAttribute, std::allocator<wlw_olp::WallOpeningAttribute>> {
    struct WallOpeningAttribute *__begin_;
    struct WallOpeningAttribute *__end_;
    struct __compressed_pair<wlw_olp::WallOpeningAttribute *, std::allocator<wlw_olp::WallOpeningAttribute>> {
        struct WallOpeningAttribute *__value_;
    } __end_cap_;
};

#pragma mark Typedef'd Structures

typedef struct {
    MISSING_TYPE *columns[3];
} CDStruct_8e0628e6;

typedef struct {
    MISSING_TYPE *columns[4];
} CDStruct_14d5dc5e;

typedef struct {
    void *plan;
    int network_index;
} CDStruct_2bc666a5;

typedef struct CDStruct_183601bc;

